{"meta":{"title":"sbwit","subtitle":"生死看淡，不服就干","description":"","author":"sbwit","url":"https://www.sbwit.com","root":"/"},"pages":[{"title":"friends","date":"2021-04-14T06:06:32.000Z","updated":"2021-04-16T03:38:51.647Z","comments":true,"path":"friends/index.html","permalink":"https://www.sbwit.com/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2021-04-14T06:06:10.000Z","updated":"2021-04-16T03:38:51.644Z","comments":true,"path":"about/index.html","permalink":"https://www.sbwit.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-14T06:05:35.000Z","updated":"2021-04-16T03:38:51.649Z","comments":true,"path":"tags/index.html","permalink":"https://www.sbwit.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-04-14T06:04:47.000Z","updated":"2021-04-16T03:38:51.646Z","comments":true,"path":"categories/index.html","permalink":"https://www.sbwit.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot单元测试","slug":"yuque/SpringBoot单元测试","date":"2021-04-13T15:40:07.000Z","updated":"2021-04-23T11:22:20.605Z","comments":true,"path":"2021/04/13/yuque/SpringBoot单元测试/","link":"","permalink":"https://www.sbwit.com/2021/04/13/yuque/SpringBoot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"在单元测试指南一文中写到过单元测试的必要性和 Java 单元测试相关的工具及方法。单元测试能帮助我们在早期就规避、发现和修复很多不易察觉的 bug 和漏洞，而且更能保障后期的需求变动和代码重构时所带来的隐患，减少测试成本和维护成本。在 SpringBoot2.x 集成和写单元测试更加容易了。 创建 SpringBoot2.x 项目在start.spring.io中创建一个自己的 SpringBoot2.x 项目，目前版本 2.1.3。选出自己需要的一些组件生成项目即可，我这里选了如下几个： Web: Web 项目 JPA: 数据库持久层采用Spring Data JPA，方便实用 Lombok: 可以通过注解大量减少 Java 中重复代码的书写 HSQLDB: 内存数据库，用来对 Repository 层做单元测试 生成之后可以在 pom.xml 中看到 SpringBoot2.x 项目中已经引入了 spring-boot-starter-test 这个启动组件，包含了几乎绝大多数测试场景需要的组件。然后通过 mvn clean install 来构建本项目或者直接导入 IDE 开发工具即可。下面将以对博客信息做简单修改和查询为示例来说明在 Spring Boot 中如何分别对 DAO，Service，Controller 做单元测试。 DAO 层的单元测试新建数据库脚本DAO 层的测试我这里采用的是 HSQLDB 的内存数据库，最好准备一些初始化的数据表结构和脚本，当然也可用直接通过官方示例的 JPA 特性和 API 代码来初始化数据。这里我还是通过脚本的方式来做，便于统一管理和维护表结构和数据。在 src/test 目录下新建 resources 资源目录，并在 resources 目录下新建 db 目录，在 db 目录下分别，新建用于管理的表结构文件(schema.sql)和初始化数据文件(data.sql)的 SQL 脚本。schema.sql 文件中的内容如下： -- 创建数据库表所在的模式 schema. CREATE SCHEMA test; commit; -- 在 test 模式下创建数据库表. DROP TABLE IF EXISTS test.t_test_blog; CREATE TABLE test.t_test_blog ( c_id varchar(32) NOT NULL, c_author varchar(255), c_content varchar(255), dt_publish_time timestamp(6) NULL, c_title varchar(255), c_url varchar(255), n_status int, c_create_user varchar(255), dt_create_time timestamp(6) NULL, dt_update_time timestamp(6) NULL, constraint pk_test_blog primary key(c_id) ); commit; data.sql 文件中的内容如下： -- 初始化插入一些博客信息数据. INSERT INTO test.t_test_blog VALUES ('1', '张三', '这是内容', '2019-03-01 00:41:01', 'Spring从入门到精通', 'https://baidu.com', '1', 'tom', '2019-03-01 00:41:33', '2019-03-01 00:41:36'); INSERT INTO test.t_test_blog VALUES ('2', '李四', '这是Mybatis的内容', '2019-03-01 00:41:01', 'Mybatis基础', 'https://qq.com', '2', 'jack', '2019-03-01 00:41:33', '2019-03-01 00:41:36'); commit; spring: datasource: url: jdbc:hsqldb:mem:db_test # 以内存数据库的方式来运行. username: root password: 123456 driver-class-name: org.hsqldb.jdbc.JDBCDriver platform: hsqldb schema: classpath:db/schema.sql data: classpath:db/data.sql jpa: show-sql: true hibernate: ddl-auto: none # 这里没用 JPA 的自动生成表结构等功能，你可以视自己的具体情况来开启. generate-ddl: false # 启动时是否初始化数据库. 准备实体 POJO 和 DAO 层 Repository 类博客信息的实体 POJO 类如下： package com.sbwit.springbootsample.pojo; import java.util.Date; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.Table; import lombok.Getter; import lombok.Setter; import lombok.experimental.Accessors; /** * 博客实体. * * @author sbwit on 2019-2-26. */ @Getter @Setter @Accessors(chain = true) @Entity @Table(name = \"t_test_blog\", schema = \"test\") public class Blog &#123; /** * ID. */ @Id @Column(name = \"c_id\") private String id; /** * 作者. */ @Column(name = \"c_author\") private String author; /** * 标题. */ @Column(name = \"c_title\") private String title; /** * 内容. */ @Column(name = \"c_content\") private String content; /** * 发布时间. */ @Column(name = \"dt_publish_time\") private Date publishTime; /** * 链接地址. */ @Column(name = \"c_url\") private String url; /** * 状态. */ @Column(name = \"n_status\") private Integer status; /** * 创建用户. */ @Column(name = \"c_create_user\") private String createUser; /** * 创建时间. */ @Column(name = \"dt_create_time\") private Date createTime; /** * 最后更新时间. */ @Column(name = \"dt_update_time\") private Date updateTime; &#125; 下面是 BlogRepository 中的一个简单的自定义@Query 查询，当然你也可以采用名称的规则来写本查询，我这里为了做示例，使用了@Query 查询。 package com.sbwit.springbootsample.repository; import com.sbwit.springbootsample.pojo.Blog; import java.util.List; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; import org.springframework.stereotype.Repository; /** * BlogRepository. * * @author sbwit on 2019-02-27. */ @Repository public interface BlogRepository extends JpaRepository&lt;Blog, String> &#123; @Query(\"SELECT b FROM Blog AS b WHERE b.title like 'Spring%'\") List&lt;Blog> querySpringBlogs(); &#125; BlogRepository 的单元测试然后在 Intellij IDEA 中通过 Ctrl + Shift + T 来为 BlogRepository 生成它对应的单元测试类 BlogRepositoryTest。 package com.sbwit.springbootsample.repository; import com.sbwit.springbootsample.pojo.Blog; import java.util.List; import java.util.Optional; import javax.annotation.Resource; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; import org.springframework.test.context.ActiveProfiles; import org.springframework.test.context.junit4.SpringRunner; /** * BlogRepositoryTest. * * @author sbwit on 2019-03-01. */ @RunWith(SpringRunner.class) @ActiveProfiles(\"hsqldb\") @DataJpaTest public class BlogRepositoryTest &#123; @Resource private BlogRepository blogRepository; /** * 测试新增博客的情况. */ @Test public void save() &#123; String id = \"newblogId\"; String title = \"Java 从入门到放弃\"; blogRepository.save(new Blog().setId(id).setTitle(title)); Optional&lt;Blog> blogOptional = blogRepository.findById(id); Assert.assertTrue(blogOptional.isPresent() &amp;&amp; title.equals(blogOptional.get().getTitle())); &#125; /** * 测试查询所有 Spring 相关的博客信息. */ @Test public void querySpringBlogs() &#123; List&lt;Blog> blogs = blogRepository.querySpringBlogs(); Assert.assertEquals(1, blogs.size()); Assert.assertEquals(\"Spring从入门到精通\", blogs.get(0).getTitle()); &#125; &#125; 这样就完成了 DAO 层代码的测试，以上程序主要依托于内存数据库 HSQLDB 和 Spring Data JPA。 Service 层的单元测试实际开发过程中，Service 层中的类依赖了 DAO 层中的类或其他 Service 类。为了隔离对其他 Service 类或 DAO 层中的类的依赖，只测试本 Service 类中的方法逻辑，就需要 Mock 数据和做打桩等操作。Spring Boot 中原生集成了Mockito，可以非常方便我们对 Java 代码做单元测试。 新建 BlogService 类package com.sbwit.springbootsample.service; import com.sbwit.springbootsample.pojo.Blog; import com.sbwit.springbootsample.repository.BlogRepository; import java.util.List; import java.util.Optional; import javax.annotation.Resource; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; /** * BlogService. * * @author sbwit on 2019-03-01. */ @Slf4j @Service public class BlogService &#123; @Resource private BlogRepository blogRepository; /** * 查询所有 Spring 相关的博客信息. * * @return 博客信息 */ public List&lt;Blog> getSpringBlogs() &#123; log.info(\"进入了获取 Spring 相关博客的 Service 方法.\"); return blogRepository.querySpringBlogs(); &#125; /** * 根据博客ID来修改该博客的名称. * * @param id 博客ID * @param title 博客标题 */ public void modifyTitileById(String id, String title) &#123; Optional&lt;Blog> blogOptional = blogRepository.findById(id); if (!blogOptional.isPresent()) &#123; log.warn(\"需要修改名称的博客不存在，id为【&#123;&#125;】请检查！\", id); return; &#125; blogRepository.save(blogOptional.get().setTitle(title)); &#125; &#125; BlogService 的单元测试通过BlogService可以生成和书写出其对应的单元测试类和测试方法，代码如下： package com.sbwit.springbootsample.service; import com.sbwit.springbootsample.pojo.Blog; import com.sbwit.springbootsample.repository.BlogRepository; import java.util.ArrayList; import java.util.List; import java.util.Optional; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.junit.MockitoJUnitRunner; /** * BlogServiceTest. * * @author sbwit on 2019-03-01. */ @RunWith(MockitoJUnitRunner.class) public class BlogServiceTest &#123; @Mock private BlogRepository blogRepository; @InjectMocks private BlogService blogService; /** * 测试service层中获取Spring相关博客的方法. */ @Test public void getSpringBlogs() &#123; // 构造需要返回的博客信息集合数据. Blog blog = new Blog() .setId(\"1\") .setTitle(\"Spring Action\"); List&lt;Blog> blogList = new ArrayList&lt;>(); blogList.add(blog); Mockito.when(blogRepository.querySpringBlogs()) .thenReturn(blogList); List&lt;Blog> blogs = blogService.getSpringBlogs(); // 断言验证查询到的数据. Assert.assertEquals(1, blogs.size()); Assert.assertEquals(\"Spring Action\", blog.getTitle()); &#125; /** * 测试根据博客ID来修改该博客的名称成功时的情况. */ @Test public void modifyTitileById() &#123; // Mock 相关数据和类方法的行为. String id = \"1\"; Mockito.when(blogRepository.findById(id)) .thenReturn(Optional.of(new Blog())); Mockito.when(blogRepository.save(Mockito.any())) .thenReturn(new Blog()); blogService.modifyTitileById(id, \"算法导论\"); // 验证 blogRepository.save(s) 方法被调用过一次. Mockito.verify(blogRepository).save(Mockito.any()); &#125; /** * 测试根据博客ID来修改该博客的名称失败时的情况. */ @Test public void modifyTitileByIdWithFailure() &#123; // Mock 未根据 ID 找到对应的博客信息的情况. String id = \"1\"; Mockito.when(blogRepository.findById(id)) .thenReturn(Optional.ofNullable(null)); blogService.modifyTitileById(id, \"算法导论\"); // 验证 blogRepository.save(s) 方法并没有被调用过. Mockito.verify(blogRepository, Mockito.never()).save(Mockito.any()); &#125; &#125; 注意：这里的@RunWith采用的是 Mocktio 提供的MockitoJUnitRunner。 这样就完成了 Service 层的单元测试，也是我们业务开发中需要重点关注和测试业务逻辑的一层。 Controller 层的单元测试Controller 层测试的重点是测试接口是否能正常工作。可以用到 Spring Boot 中提供的@WebMvcTest 注解来模拟 Web 层的单元测试。当然，也需要通过 Mock 的方式类隔离对 Service 层各个类的依赖影响。 新建 BlogController 类package com.sbwit.springbootsample.controller; import com.sbwit.springbootsample.pojo.Blog; import com.sbwit.springbootsample.service.BlogService; import java.util.List; import javax.annotation.Resource; import lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PatchMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; /** * BlogController. * * @author sbwit on 2019-02-28. */ @Slf4j @RequestMapping(\"/blogs\") @RestController public class BlogController &#123; @Resource private BlogService blogService; /** * 获取所有 Spring 相关的博客信息. * * @return Spring相关的博客信息 */ @GetMapping public ResponseEntity&lt;List&lt;Blog>> getSpringBlogs() &#123; return ResponseEntity.ok(blogService.getSpringBlogs()); &#125; /** * 根据博客ID修改博客名称. * * @param id 博客ID * @param title 博客标题 * @return 空 */ @PatchMapping(\"/&#123;id&#125;\") public ResponseEntity&lt;Void> modifyTitileById(@PathVariable(\"id\") String id, @RequestParam(\"title\") String title) &#123; try &#123; blogService.modifyTitileById(id, title); log.info(\"修改博客名称成功.\"); return new ResponseEntity&lt;>(HttpStatus.OK); &#125; catch (Exception e) &#123; log.error(\"修改博客名称出错，id为【&#123;&#125;】.\", id); return new ResponseEntity&lt;>(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; &#125; package com.sbwit.springbootsample.controller; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; import com.blinkfox.springbootsample.service.BlogService; import java.util.ArrayList; import javax.annotation.Resource; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mockito; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; /** * BlogControllerTest. * * @author sbwit on 2019-03-02. */ @RunWith(SpringRunner.class) @WebMvcTest(BlogController.class) public class BlogControllerTest &#123; @Resource private MockMvc mockMvc; @MockBean private BlogService blogService; /** * 测试获取所有 Spring 相关的博客信息. * * @throws Exception 异常 */ @Test public void getSpringBlogs() throws Exception &#123; Mockito.when(blogService.getSpringBlogs()) .thenReturn(new ArrayList&lt;>()); this.mockMvc.perform(get(\"/blogs\")) .andExpect(status().isOk()); &#125; /** * 测试修改博客标题成功时的情况. * * @throws Exception 异常 */ @Test public void modifyTitileById() throws Exception &#123; Mockito.doNothing() .when(blogService).modifyTitileById(Mockito.anyString(), Mockito.anyString()); this.mockMvc.perform(patch(\"/blogs/1?title=Spring实战\")) .andExpect(status().isOk()); &#125; /** * 测试修改博客标题失败时的情况. * * @throws Exception 异常 */ @Test public void modifyTitileByIdWithException() throws Exception &#123; Mockito.doThrow(RuntimeException.class) .when(blogService).modifyTitileById(Mockito.anyString(), Mockito.anyString()); this.mockMvc.perform(patch(\"/blogs/1?title=Spring实战\")) .andExpect(status().is5xxServerError()); &#125; &#125; 以上就完成了对 Controller 层的单元测试。 总结在 Spring Boot 中做单元测试的将会非常容易。上面只是 Spring Boot 中提供的部分方式，Spring Boot 文档中还有其他更多的测试场景和测试方法供你去参考和使用。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.sbwit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.sbwit.com/tags/SpringBoot/"},{"name":"单元测试","slug":"单元测试","permalink":"https://www.sbwit.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"单元测试指南","slug":"yuque/单元测试指南","date":"2021-04-13T15:40:07.000Z","updated":"2021-04-23T11:22:20.493Z","comments":true,"path":"2021/04/13/yuque/单元测试指南/","link":"","permalink":"https://www.sbwit.com/2021/04/13/yuque/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"","text":"一、必要性在我们公司中要做单元测试，确实比较难，因为公司缺少这种氛围，有也只是局部的，大多数工程师没有这方面的习惯和素养，很多人都是有一定的抵触的心理，经过我私下的了解大概有以下几种原因吧。 写单元测试太耗费时间了，项目要赶进度，编写单元测试会导致不能按时完成开发任务，导致项目延期； 做传统 xx 管理系统的项目，业务逻辑比较简单，主要就是对业务数据做增删改查，单元测试意义和价值不高； 公司有专门的测试人员，很多问题在集成测试时一定能发现。 以前项目上从没写过单元测试，没有经验，不知道怎么编写单元测试； 这其中对单元测试就有些误解了，单元测试有几个比较常见的典型场景： 开发前写单元测试，通过测试描述需求，即测试驱动开发。 在开发过程中及时得到反馈，提前规避隐患和发现问题。 应用于自动化构建或持续集成流程，对每次代码修改做回归测试。 作为重构的基础，验证重构是否可靠。 还有最重要的一点：编写单元测试的难易程度能够直接反应出代码的设计水平，能写出单元测试和写不出单元测试之间体现了编程能力上的巨大的鸿沟。无论是什么样的程序员，坚持编写一段时间的单元测试之后，都会明显感受到代码设计能力的巨大提升。公司开发人员的代码质量往往不是很高，尤其是对代码的拆分和逻辑的抽象还处于懵懂阶段。要对这类代码写单测，即使是工作了 3，4 年的高级码农也是一个挑战，对新人来说几乎是不可能完成的任务。这也让很多开发人员有了写单元测试很难的感觉。所以，写单元测试的难易程度跟代码的质量关系最大，并且是决定性的。项目里无论用了哪个测试框架都不能解决代码本身难以测试的问题。诚然，写单元测试在开发期间的确是会耗费更多时间的，尤其是要追求很高(超过 80%，甚至 100%)的代码覆盖率，更是需要耗费大量心血才能达到的。对于一些只需一次交付，很少维护的项目来说，意义和价值确实不是很大。但这本质上是属于为了赚快钱，不负责任的行为了，毕竟谁都无法保障自己写的程序，真的没有丝毫问题。这个问题的出现并不是个人的问题，而是反映了公司项目管理中的问题。当然，个人的原因也存在，就是如何在有限的时间里，提高效率。目前公司的大多数项目其实都有着至少两年的维护时间的，很多开发人员都不愿意把自己的时间耗在一个代码很烂、没有单元测试保障且经常变更需求的项目里面。总之，包括我本人在内，都是有项目维护恐惧症的，更愿意投入到新项目的开发中。但是新项目里面还是没有单元测试的保障，代码质量逐渐低劣，如此就又形成了一个不断的循环之中。无法挣脱这个循环的人员就只能选择离职了，也许不慎又到了新的漩涡里面。一个 bug 被隐藏的时间越长，修复这个 bug 的代价就越大。单元测试能帮助我们在早期就规避、发现和修复很多不易察觉的 bug 和漏洞，而且更能保障后期的需求变动和代码重构时所带来的隐患，减少测试成本和维护成本。所以，在新项目中逐步推广和编写单元测试是有必要的，这将大大提高项目中代码的质量和可靠性，有些老项目中就算了吧，往往维护人员的负面情绪可能会更多，一些新的功能特性倒是可以试试。虽然写好单元测试很难，但写单元测试的难度其实是小于决定写单元测试的勇气的。 二、基本概念单元测试：单元测试又称模块测试，属于白盒测试，是最小单位的测试。模块分为程序模块和功能模块。功能模块指实现了一个完整功能的模块（单元），一个完整的程序单元具备输入、加工和输出三个环节。而且每个程序单元都应该有正规的规格说明，使之对其输入、加工和输出的关系做出名明确的描述。驱动测试：驱动被测试模块正常运行起来的实体。通俗的说法就是你负责测试模块/方法是中间的，没有 main()方法入口，怎么编译，怎么启动呢？就需要写一个带 main()的方法来调用你的模块/方法，这个就是驱动测试。测试桩：代替被测模块调用的子模块的实体，该实体一般为桩函数（stub）。通俗的说法就是你负责测试的模块/方法所调用的模块/方法，所以你需要模仿他们做一个返回值（假的，但符合设计）。测试覆盖：评测测试过程中已经执行的代码的多少。测试覆盖率：代码的覆盖程度，一种度量方式。针对代码的测试覆盖率有很多种度量方式，常见的有以下几种: 语句覆盖 判定覆盖 路径覆盖 测试覆盖率数据到底有多大意义。主要有以下几个观点： 路径覆盖率 &gt; 判定覆盖 &gt; 语句覆盖 覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。 不要过于相信覆盖率数据，100%的测试覆盖率并不能保证 bug 的不出现。 代码覆盖率只是一个最基本的前提，一定要保证，但不是意味着达到指标就代表测试的完成 测试人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。 三、单元测试工具在 Java 中有非常多的单元测试的工具或框架可供选择，我这里只选择一些常用的、主流的单元测试框架或者工具来作介绍和使用。 JUnit：Java 中最有名、使用最广泛的单元测试框架 Mockito：模拟框架，可以让你用干净而简单的 API 编写测试 Spring Test: 使用 Spring Test 来对 Spring 相关的项目做单元测试，其中会结合或者集成其他测试框架和工具 spring-boot-starter-test: SpringBoot 项目中的单元测试 JaCoCo: 使用离线和运行时字节码工具来收集代码覆盖率指标的框架。 1. JUnit4JUnit 是使用 Java 语言编写的用于编写和运行可重复的自动化测试的开源测试框架。除了 Junit 之外，TestNg也是 Java 中非常受欢迎的单元测试框架。两种框架在功能上看起来非常相似，这里有一篇关于JUnit 4 与 TestNG 的对比，还有一篇较为全面的介绍TestNG 的教程，总体来说，TestNG 比 Junit4 功能更强大一些，但是相比 Junit5 而言，TestNG 又落后了一代。开源的轮子滚滚向前，都是一代新的轮子超越一代老的轮子。所以，我们这里就只选择 Junit 来作单元测试框架的介绍了吧。JUnit4 和 TestNG 的功能比较目前最新版本是 JUnit5.2.0，相比 JUnit4 而言有很大的改变，这里主要讲解 JUnit4 的使用(目前的新老项目中应该使用的更多)，并对 JUnit5 做简要介绍。学习了 Junit4 的主要使用方式之后，大家再去看JUnit5 用户指南在将来逐渐使用起来更好些。 (1). 简单示例import static org.junit.Assert.*; import org.junit.Test; public class CalculateTest &#123; @Test public void testSum() &#123; Calculate calculation = new Calculate(); int sum = calculation.sum(2, 5); int testSum = 7; System.out.println(\"@Test sum(): \" + sum + \" = \" + testSum); assertEquals(sum, testSum); &#125; &#125; (2). 注解 @Test: 测试方法，在这里还可以测试期望异常和超时时间。 @Before: 每个测试方法执行之前执行的方法。 @BeforeClass: 一个测试类中所有测试方法执行之前执行的方法，只执行一次，且方法必须为 static 的。 @After: 每个测试方法执行之后执行的方法。 @AfterClass: 一个测试类中所有测试方法执行之后执行的方法，只执行一次，且方法必须为 static 的。 @Ignore: 忽略的测试方法。 @RunWith: 指定测试类使用某个运行器。 @Parameters: 参数化测试，指定测试类的测试数据集合。 @FixMethodOrder: 注解在测试类上指定测试方法按一定顺序规则来执行，有三种。 一个测试类单元测试的执行顺序为：@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass每一个测试方法的执行顺序为：@Before –&gt; @Test –&gt; @After综合示例： import static org.junit.Assert.*; import java.util.*; import org.junit.*; public class AnnotationsTest &#123; private ArrayList testList; @BeforeClass public static void onceExecutedBeforeAll() &#123; System.out.println(\"@BeforeClass: onceExecutedBeforeAll\"); &#125; @Before public void executedBeforeEach() &#123; testList = new ArrayList(); System.out.println(\"@Before: executedBeforeEach\"); &#125; @AfterClass public static void onceExecutedAfterAll() &#123; System.out.println(\"@AfterClass: onceExecutedAfterAll\"); &#125; @After public void executedAfterEach() &#123; testList.clear(); System.out.println(\"@After: executedAfterEach\"); &#125; @Test public void EmptyCollection() &#123; assertTrue(testList.isEmpty()); System.out.println(\"@Test: EmptyArrayList\"); &#125; @Test public void OneItemCollection() &#123; testList.add(\"oneItem\"); assertEquals(1, testList.size()); System.out.println(\"@Test: OneItemArrayList\"); &#125; @Ignore public void executionIgnored() &#123; System.out.println(\"@Ignore: This execution is ignored\"); &#125; &#125; 如果我们运行上面的测试，控制台输出将是以下几点： @BeforeClass: onceExecutedBeforeAll @Before: executedBeforeEach @Test: EmptyArrayList @After: executedAfterEach @Before: executedBeforeEach @Test: OneItemArrayList @After: executedAfterEach @AfterClass: onceExecutedAfterAll (3). 断言断言是编写测试用例的核心实现方式，即期望值是多少，测试的结果是多少，以此来判断测试是否通过。JUnit4.x 中的断言核心方法如下： assertArrayEquals(expecteds, actuals): 查看两个数组是否相等。 assertEquals(expected, actual): 查看两个对象是否相等。类似于字符串比较使用的 equals()方法。 assertNotEquals(first, second): 查看两个对象是否不相等。 assertNull(object): 查看对象是否为空。 assertNotNull(object): 查看对象是否不为空。 assertSame(expected, actual): 查看两个对象的引用是否相等。类似于使用“==”比较两个对象。 assertNotSame(unexpected, actual): 查看两个对象的引用是否不相等。类似于使用“!=”比较两个对象。 assertTrue(condition): 查看运行结果是否为 true。 assertFalse(condition): 查看运行结果是否为 false。 assertThat(actual, matcher): 查看实际值是否满足指定的条件。 fail(): 让测试失败。 (4). 套件测试测试套件意味着捆绑几个单元测试用例并且一起执行他们。在 JUnit 中，@RunWith 和@Suite 注释用来运行套件测试。简单示例如下： public class TestJunit1 &#123; @Test public void testPrint1() &#123; System.out.println(\"Test Junit 1...\"); &#125; &#125; public class TestJunit2 &#123; @Test public void testPrint2() &#123; System.out.println(\"Test Junit 2...\"); &#125; &#125; @RunWith(Suite.class) @Suite.SuiteClasses(&#123; TestJunit1.class, TestJunit2.class &#125;) public class JunitTestSuite &#123; &#125; (5). 参数化测试一个测试类也可以被看作是一个参数化测试类。但它要满足下列所有要求： 该类被注解为@RunWith(Parameterized.class)。 这个类有一个构造函数，存储测试数据。 这个类有一个静态方法生成并返回测试数据，并注明@Parameters 注解。 这个类有一个测试，它需要注解@Test 到方法。 简单示例如下： import static org.junit.Assert.assertEquals; import java.util.Arrays; import java.util.Collection; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class) public class CalculateTest &#123; private int expected; private int first; private int second; public CalculateTest(int expectedResult, int firstNumber, int secondNumber) &#123; this.expected = expectedResult; this.first = firstNumber; this.second = secondNumber; &#125; @Parameters public static Collection addedNumbers() &#123; return Arrays.asList(new Integer[][] &#123; &#123; 3, 1, 2 &#125;, &#123; 5, 2, 3 &#125;, &#123; 7, 3, 4 &#125;, &#123; 9, 4, 5 &#125;, &#125;); &#125; @Test public void sum() &#123; Calculate add = new Calculate(); System.out.println(\"Addition with parameters : \" + first + \" and \" + second); assertEquals(expected, add.sum(first, second)); &#125; &#125; 运行 CalculateTest 测试用例，控制台输出如下： Addition with parameters : 1 and 2 Adding values: 1 + 2 Addition with parameters : 2 and 3 Adding values: 2 + 3 Addition with parameters : 3 and 4 Adding values: 3 + 4 Addition with parameters : 4 and 5 Adding values: 4 + 5 (6). 忽略测试有时可能会发生我们的代码还没有准备好的情况，这时测试用例去测试这个方法或代码的时候会造成失败。@Ignore 注释会在这种情况时帮助我们。 一个含有@Ignore 注释的测试方法将不会被执行。 如果一个测试类有@Ignore 注释，则它的测试方法将不会执行 public class JunitTest3 &#123; @Test @Ignore(\"该测试方法还没准备好运行.\") public void testHello() &#123; System.out.println(\"Hello World!\"); &#125; &#125; 在上面的示例中，JUnit 将不会执行 testHello()方法。 (7). 异常测试它用于测试由方法抛出的异常。 import org.junit.*; public class JunitTest4 &#123; @Test(expected = ArithmeticException.class) public void testWithException() &#123; int i = 1 / 0; &#125; &#125; 在上面的示例中，testWithException()方法将抛出 ArithmeticException 异常，因为这是一个预期的异常，因此单元测试会通过。 (8). 超时测试超时测试是指，一个单元测试运行时间是否超过指定的毫秒数，测试将终止并标记为失败。 import org.junit.*; public class JunitTest5 &#123; @Test(timeout = 1000) public void testTimeout() &#123; while (true) &#123; // do nothing. &#125; &#125; &#125; 在上面的示例中，testTimeout()方法将不会返回，因此 JUnit 引擎会将其标记为失败，并抛出一个异常。java.lang.Exception:test timed out after 1000 milliseconds。 (9). Hamcrest在实际开发中，一些基本的断言，如 eqaul,null,true 它们的可读性并不是很好。而且很多时候我们要比较对象、集合、Map 等数据结构。这样我们要么进行大段的字段获取再断言。或者干脆自己编写表达式并断言其结果。JUnit4.4 引入了 Hamcrest 框架，Hamcest 提供了一套匹配符 Matcher，这些匹配符更接近自然语言，可读性高，更加灵活。Hamcrest提供了大量被称为“匹配器”的方法。其中每个匹配器都设计用于执行特定的比较操作。Hamcrest 的可扩展性很好，让你能够创建自定义的匹配器。最重要的是，JUnit 也包含了 Hamcrest 的核心，提供了对 Hamcrest 的原生支持，可以直接使用 Hamcrest。当然要使用功能齐备的 Hamcrest，还是要引入对它的依赖。看个对比例子，前者使用 Junit 的 断言，后者使用 Hamcrest 的断言。 @Test public void test_with_junit_assert() &#123; int expected = 51; int actual = 51; assertEquals(\"failure - They are not same!\", expected, actual); &#125; @Test public void test_with_hamcrest_assertThat() &#123; int expected = 51; int actual = 51; assertThat(\"failure - They are not same!\", actual, equalTo(expected)); &#125; // 联合匹配符not和equalTo表示“不等于” assertThat( something, not( equalTo( \"developer\" ) ) ); // 联合匹配符not和containsString表示“不包含子字符串” assertThat( something, not( containsString( \"Works\" ) ) ); // 联合匹配符anyOf和containsString表示“包含任何一个子字符串” assertThat(something, anyOf(containsString(\"developer\"), containsString(\"Works\"))); 使用 assertThat 的优点： Hamcrest 一条 assertThat 即可以替代其他所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。 assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活 assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。 可以将这些 Matcher 匹配符联合起来灵活使用，达到更多目的。 JUnit 4.4 自带了一些 Hamcrest 的匹配符 Matcher，但是只有有限的几个，在类 org.hamcrest.CoreMatchers 中定义，要想使用他们，必须导入包 org.hamcrest.CoreMatchers.*。Hamcrest 提供了很强大的一些 api 供我们进行测试断言。 核心： anything - 总是匹配,如果你不关心测试下的对象是什么是有用的 describedAs - 添加一个定制的失败表述装饰器 is - 改进可读性装饰器 - 见下 “Sugar” 逻辑： allOf - 如果所有匹配器都匹配才匹配,像Java里的&amp;&amp; anyOf - 如果任何匹配器匹配就匹配,像Java里的|| not - 如果包装的匹配器不匹配器时匹配,反之亦然 对象： equalTo - 测试对象相等使用Object.equals方法 hasToString - 测试Object.toString方法 instanceOf, isCompatibleType - 测试类型 notNullValue, nullValue - 测试null sameInstance - 测试对象实例 Beans： hasProperty - 测试JavaBeans属性 集合： array - 测试一个数组元素test an array’s elements against an array of matchers hasEntry, hasKey, hasValue - 测试一个Map包含一个实体,键或者值 hasItem, hasItems - 测试一个集合包含一个元素 hasItemInArray - 测试一个数组包含一个元素 数字： closeTo - 测试浮点值接近给定的值 greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 测试次序 文本： equalToIgnoringCase - 测试字符串相等忽略大小写 equalToIgnoringWhiteSpace - 测试字符串忽略空白 containsString, endsWith, startsWith - 测试字符串匹配 以下示例代码列举了大部分 assertThat 的使用例子，供大家学习使用时参考： //---------------- 字符相关匹配符 ---------------- /**equalTo匹配符断言被测的testedValue等于expectedValue， * equalTo可以断言数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法 */ assertThat(testedValue, equalTo(expectedValue)); /**equalToIgnoringCase匹配符断言被测的字符串testedString *在忽略大小写的情况下等于expectedString */ assertThat(testedString, equalToIgnoringCase(expectedString)); /**equalToIgnoringWhiteSpace匹配符断言被测的字符串testedString *在忽略头尾的任意个空格的情况下等于expectedString， *注意：字符串中的空格不能被忽略 */ assertThat(testedString, equalToIgnoringWhiteSpace(expectedString); /**containsString匹配符断言被测的字符串testedString包含子字符串subString**/ assertThat(testedString, containsString(subString)); /**endsWith匹配符断言被测的字符串testedString以子字符串suffix结尾*/ assertThat(testedString, endsWith(suffix)); /**startsWith匹配符断言被测的字符串testedString以子字符串prefix开始*/ assertThat(testedString, startsWith(prefix)); // ---------------- 一般匹配符 ---------------- /**nullValue()匹配符断言被测object的值为null*/ assertThat(object,nullValue()); /**notNullValue()匹配符断言被测object的值不为null*/ assertThat(object,notNullValue()); /**is匹配符断言被测的object等于后面给出匹配表达式*/ assertThat(testedString, is(equalTo(expectedValue))); /**is匹配符简写应用之一，is(equalTo(x))的简写，断言testedValue等于expectedValue*/ assertThat(testedValue, is(expectedValue)); /**is匹配符简写应用之二，is(instanceOf(SomeClass.class))的简写， *断言testedObject为Cheddar的实例 */ assertThat(testedObject, is(Cheddar.class)); /**not匹配符和is匹配符正好相反，断言被测的object不等于后面给出的object*/ assertThat(testedString, not(expectedString)); /**allOf匹配符断言符合所有条件，相当于“与”（&amp;&amp;）*/ assertThat(testedNumber, allOf(greaterThan(8), lessThan(16))); /**anyOf匹配符断言符合条件之一，相当于“或”（||）*/ assertThat(testedNumber, anyOf(greaterThan(16), lessThan(8))); // ---------------- 数值相关匹配符 ---------------- /**closeTo匹配符断言被测的浮点型数testedDouble在20.0¡À0.5范围之内*/ assertThat(testedDouble, closeTo(20.0, 0.5)); /**greaterThan匹配符断言被测的数值testedNumber大于16.0*/ assertThat(testedNumber, greaterThan(16.0)); /** lessThan匹配符断言被测的数值testedNumber小于16.0*/ assertThat(testedNumber, lessThan (16.0)); /** greaterThanOrEqualTo匹配符断言被测的数值testedNumber大于等于16.0*/ assertThat(testedNumber, greaterThanOrEqualTo (16.0)); /** lessThanOrEqualTo匹配符断言被测的testedNumber小于等于16.0*/ assertThat(testedNumber, lessThanOrEqualTo (16.0)); // ---------------- 集合相关匹配符 ---------------- /**hasEntry匹配符断言被测的Map对象mapObject含有一个键值为\"key\"对应元素值为\"value\"的Entry项*/ assertThat(mapObject, hasEntry(\"key\", \"value\")); /**hasItem匹配符表明被测的迭代对象iterableObject含有元素element项则测试通过*/ assertThat(iterableObject, hasItem (element)); /** hasKey匹配符断言被测的Map对象mapObject含有键值“key”*/ assertThat(mapObject, hasKey (\"key\")); /** hasValue匹配符断言被测的Map对象mapObject含有元素值value*/ assertThat(mapObject, hasValue(value)); 2. JUnit5(1). Junit5 简介JUnit 5 跟以前的 JUnit 版本不一样，它由几大不同的模块组成，这些模块分别来自三个不同的子项目。JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit VintageJUnit Platform 是在 JVM 上 启动测试框架 的基础平台。它还定义了 TestEngine API，该 API 可用于开发在平台上运行的测试框架。此外，平台还提供了一个从命令行或者 Gradle 和 Maven 插件来启动的 控制台启动器 ，它就好比一个 基于 JUnit4 的 Runner 在平台上运行任何 TestEngine。JUnit Jupiter 是一个组合体，它是由在 JUnit 5 中编写测试和扩展的新 编程模型 和 扩展模型 组成。另外，Jupiter 子项目还提供了一个 TestEngine，用于在平台上运行基于 Jupiter 的测试。JUnit Vintage 提供了一个 TestEngine，用于在平台上运行基于 JUnit 3 和 JUnit 4 的测试。JUnit 5 需要 Java 8（或更高）的运行时环境。不过，你仍然可以测试那些由老版本 JDK 编译的代码。 (2). 简单示例import static org.junit.jupiter.api.Assertions.assertEquals; import org.junit.jupiter.api.Test; class FirstJUnit5Tests &#123; @Test void myFirstTest() &#123; assertEquals(2, 1 + 1); &#125; &#125; 表面上来看，使用方式和 Junit4 差别不大，但是与 JUnit4 比较起来还是有些不同的。 导入测试测试注解（@Test）和断言方法（assertEquals）的包路径不同。 不需要手动把测试和测试方法声明为 public 了。 (3). 注解JUnit Jupiter 支持使用下面表格中的注解来配置测试和扩展框架。所有的核心注解都位于 junit-jupiter-api 模块的 org.junit.jupiter.api`包中。 @Test: 表示该方法是一个测试方法。与 JUnit 4 的@Test 注解不同的是，它没有声明任何属性，因为 JUnit Jupiter 中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖。 @ParameterizedTest: 表示该方法是一个参数化测试（可以用不同的参数多次运行试）。这样的方法会被继承，除非它们被覆盖。 @RepeatedTest: 表示该方法是一个重复测试的测试模板(让某个测试方法运行多次)。这样的方法会被继承，除非它们被覆盖。 @TestFactory: 表示该方法是一个动态测试的测试工厂。这样的方法会被继承，除非它们被覆盖。 @TestInstance: 用于配置所标注的测试类的测试实例生命周期。这些注解会被继承。 @TestTemplate: 表示该方法是一个测试模板，它会依据注册的提供者所返回的调用上下文的数量被多次调用。这样的方法会被继承，除非它们被覆盖。 @DisplayName: 为测试类或测试方法声明一个自定义的显示名称(空格、特殊字符甚至是 emojis 表情)。该注解不能被继承。 @BeforeEach: 表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest 或者@TestFactory 注解的方法之前执行；类似于 JUnit4 的@Before。这样的方法会被继承，除非它们被覆盖。 @AfterEach: 表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest 或者@TestFactory 注解的方法之后执行；类似于 JUnit4 的@After。这样的方法会被继承，除非它们被覆盖。 @BeforeAll: 表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest 或者@TestFactory 注解的方法之前执行；类似于 JUnit4 的@BeforeClass。这样的方法会被继承（除非它们被隐藏或覆盖），并且它必须是 static 方法（除非”per-class” 测试实例生命周期被使用）。 @AfterAll: 表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest 或者@TestFactory 注解的方法之后执行；类似于 JUnit4 的@AfterClass。这样的方法会被继承（除非它们被隐藏 或覆盖），并且它必须是 static 方法（除非”per-class” 测试实例生命周期被使用）。 @Nested: 表示使用了该注解的类是一个内嵌、非静态的测试类(让测试编写者能够表示出几组测试用例之间的关系)。@BeforeAll 和@AfterAll 方法不能直接在@Nested 测试类中使用，（除非”per-class”测试实例生命周期被使用）。该注解不能被继承。 @Tag: 用于声明过滤测试的 tags，该注解可以用在方法或类上；类似于 TesgNG 的测试组或 JUnit4 的分类。该注解能被继承，但仅限于类级别，而非方法级别。 @Disable: 用于禁用一个测试类或测试方法；类似于 JUnit4 的@Ignore。该注解不能被继承。 @ExtendWith: 用于注册自定义扩展。该注解不能被继承。 注：被@Test、@TestTemplate、@RepeatedTest、@BeforeAll、@AfterAll、@BeforeEach 或 @AfterEach 注解标注的方法不可以有返回值。在 JUnit5 中的一个测试类的基本生命周期示例如下： @DisplayName(\"Junit5的测试示例类\") class LifecycleTest &#123; @BeforeAll @DisplayName(\"资源初始化方法\") static void initializeExternalResources() &#123; System.out.println(\"Initializing external resources...\"); &#125; @BeforeEach void initializeMockObjects() &#123; System.out.println(\"Initializing mock objects...\"); &#125; @Test void someTest() &#123; System.out.println(\"Running some test...\"); assertTrue(true); &#125; @Test void otherTest() &#123; assumeTrue(true); System.out.println(\"Running another test...\"); assertNotEquals(1, 42, \"Why wouldn't these be the same?\"); &#125; @Test @Disabled @DisplayName(\"该方法先不执行.\") void disabledTest() &#123; System.exit(1); &#125; @AfterEach void tearDown() &#123; System.out.println(\"Tearing down...\"); &#125; @AfterAll static void freeExternalResources() &#123; System.out.println(\"Freeing external resources...\"); &#125; &#125; 由于 JUnit5 中的新特性很多，限于篇幅就简单介绍到这里了，如想详细了解 Junit5 的更多特性，请前往Junit5 官网和JUnit5 用户指南中文版去查看。 3. Mockito在软件开发中提及Mock，通常理解为模拟对象。为什么需要模拟? 在我们一开始学编程时,我们所写的对象通常都是独立的，并不依赖其他的类，也不会操作别的类。但实际上，软件中是充满依赖关系的，比如我们会基于 service 业务操作类,而 service 类又是基于数据访问类(DAO)的，依次下去，形成复杂的依赖关系。单元测试的思路就是我们想在不涉及依赖关系的情况下测试代码。这种测试可以让你无视代码的依赖关系去测试代码的有效性。核心思想就是如果代码按设计正常工作，并且依赖关系也正常，那么他们应该会同时工作正常。有些时候，我们代码所需要的依赖可能尚未开发完成，甚至还不存在，那如何让我们的开发进行下去呢？使用 mock 可以让开发进行下去，mock 技术的目的和作用就是模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试与测试边界以外的对象隔离开。我们可以自己编写自定义的 Mock 对象实现 Mock 技术，但是编写自定义的 Mock 对象需要额外的编码工作，同时也可能引入错误。现在实现 Mock 技术的优秀开源框架有很多，Mockito就是一个优秀的用于单元测试的 Mock 框架。除了 Mockito 以外，还有一些类似的框架，比如： EasyMock：早期比较流行的 MocK 测试框架。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。 PowerMock：这个工具是在 EasyMock 和 Mockito 上扩展出来的，目的是为了解决 EasyMock 和 Mockito 不能解决的问题（比如对 static,final,private 方法均不能 Mock）。其实测试架构设计良好的代码，一般并不需要这些功能，但如果是在已有项目上增加单元测试，老代码有问题且不能改时，就不得不使用这些功能了。 JMockit：JMockit 是一个轻量级的 mock 框架是用以帮助开发人员编写测试程序的一组工具和 API，该项目完全基于 Java 5 SE 的 java.lang.instrument 包开发，内部使用 ASM 库来修改 Java 的 Bytecode`。 WireMock: 模拟您的 API 以进行快速、可靠和全面的测试。WireMock 是一个基于 HTTP 的 API 的模拟器。有些人可能认为它是一个服务虚拟化工具或模拟服务器。 Mockito 已经被广泛应用，所以这里重点介绍 Mockito，其他的 Mock 框架也各自有自己的特点，大家下来自己学习或者分享，参考的Mockito 中文文档在这里。下面的例子大多都会模拟一个 List，因为大多数人都熟悉它（比如 add()，get()，clear()等方法）。实际上，请不要模拟 List 类，改用真实的实例。 (1). 验证行为一旦创建，mock 会记录所有交互，你可以验证所有你想要验证的东西。 // 静态导入会使代码更简洁 import static org.mockito.Mockito.*; // 创建mock对象 List mockedList = mock(List.class); // 使用mock对象 mockedList.add(\"one\"); mockedList.clear(); // 验证行为 verify(mockedList).add(\"one\"); verify(mockedList).clear(); Mock 一旦创建，模拟对象将记住你的所有的交互。然后，您可以选择性地验证您感兴趣的任何行为。 (2). 如何做一些测试打桩(stubbing)// 你可以mock具体的类型,不仅只是接口 LinkedList mockedList = mock(LinkedList.class); // 测试桩 when(mockedList.get(0)).thenReturn(\"first\"); when(mockedList.get(1)).thenThrow(new RuntimeException()); // 输出“first” System.out.println(mockedList.get(0)); // 抛出异常 System.out.println(mockedList.get(1)); // 因为get(999) 没有打桩，因此输出null System.out.println(mockedList.get(999)); // 验证get(0)被调用的次数 verify(mockedList).get(0); 默认情况下，所有的函数都有返回值。mock 函数默认返回的是 null，一个空的集合或者一个被对象类型包装的内置类型，例如 0、false 对应的对象类型为 Integer、Boolean； 测试桩函数可以被覆写: 例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法； 一旦测试桩函数被调用，该函数将会一致返回固定的值； 上一次调用测试桩函数有时候极为重要，当你调用一个函数很多次时，最后一次调用可能是你所感兴趣的。 (3). 参数匹配器(matchers)Mockito 以自然的 java 风格来验证参数值: 使用 equals()函数。有时，当需要额外的灵活性时你可能需要使用参数匹配器，也就是 argument matchers: // 使用内置的anyInt()参数匹配器 when(mockedList.get(anyInt())).thenReturn(\"element\"); // 使用自定义的参数匹配器( 在isValid()函数中返回你自己的匹配器实现 ) when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\"); // 输出element System.out.println(mockedList.get(999)); // 你也可以验证参数匹配器 verify(mockedList).get(anyInt()); 参数匹配器使验证和测试桩变得更灵活。点击这里可以查看更多内置的匹配器以及自定义参数匹配器或者 hamcrest 匹配器的示例。 (4). 验证函数的确切、最少、从未调用次数// 使用模拟对象 mockedList.add(\"once\"); mockedList.add(\"twice\"); mockedList.add(\"twice\"); mockedList.add(\"three times\"); mockedList.add(\"three times\"); mockedList.add(\"three times\"); // 下面的两个验证函数效果一样,因为verify默认验证的就是times(1) verify(mockedList).add(\"once\"); verify(mockedList, times(1)).add(\"once\"); // 验证具体的执行次数 verify(mockedList, times(2)).add(\"twice\"); verify(mockedList, times(3)).add(\"three times\"); // 使用never()进行验证,never相当于times(0) verify(mockedList, never()).add(\"never happened\"); // 使用atLeast()/atMost() verify(mockedList, atLeastOnce()).add(\"three times\"); verify(mockedList, atLeast(2)).add(\"five times\"); verify(mockedList, atMost(5)).add(\"three times\"); verify 函数默认验证的是执行了 times(1)，也就是某个测试函数是否执行了 1 次.因此，times(1)通常被省略了。 (5). 为返回值为 void 的函数通过 Stub 抛出异常doThrow(new RuntimeException()).when(mockedList).clear(); // 调用这句代码会抛出异常 mockedList.clear(); 当你调用 doThrow(),doAnswer(),doNothing(),doReturn()anddoCallRealMethod()这些函数时可以在适当的位置调用 when()函数. 当你需要下面这些功能时这是必须的: 测试 void 函数 在受监控的对象上测试函数 不知一次的测试为同一个函数，在测试过程中改变 mock 对象的行为。 但是在调用 when()函数时你可以选择是否调用这些上述这些函数。 (6). 验证执行执行顺序// A. 验证mock一个对象的函数执行顺序 // 创建Mock对象 List singleMock = mock(List.class); // 使用mock对象 singleMock.add(\"was added first\"); singleMock.add(\"was added second\"); // 为该mock对象创建一个inOrder对象 InOrder inOrder = inOrder(singleMock); // 确保add函数首先执行的是add(\"was added first\"),然后才是add(\"was added second\") inOrder.verify(singleMock).add(\"was added first\"); inOrder.verify(singleMock).add(\"was added second\"); // B .验证多个mock对象的函数执行顺序 List firstMock = mock(List.class); List secondMock = mock(List.class); // 使用mock对象 firstMock.add(\"was called first\"); secondMock.add(\"was called second\"); // 为这两个Mock对象创建inOrder对象 InOrder inOrder = inOrder(firstMock, secondMock); // 验证它们的执行顺序 inOrder.verify(firstMock).add(\"was called first\"); inOrder.verify(secondMock).add(\"was called second\"); 验证执行顺序是非常灵活的。你不需要一个一个的验证所有交互,只需要验证你感兴趣的对象即可。另外，你可以仅通过那些需要验证顺序的 mock 对象来创建 InOrder 对象。 (7). 确保交互(interaction)操作不会执行在 mock 对象上// 使用Mock对象 mockOne.add(\"one\"); // 普通验证 verify(mockOne).add(\"one\"); // 验证某个交互是否从未被执行 verify(mockOne, never()).add(\"two\"); // 验证mock对象没有交互过 verifyZeroInteractions(mockTwo, mockThree); (8). 查找冗余的调用// 使用mock对象 mockedList.add(\"one\"); mockedList.add(\"two\"); verify(mockedList).add(\"one\"); // 下面的验证将会失败 verifyNoMoreInteractions(mockedList); 一些用户可能会在频繁地使用 verifyNoMoreInteractions()，甚至在每个测试函数中都用。但是 verifyNoMoreInteractions()并不建议在每个测试函数中都使用。verifyNoMoreInteractions()在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时。滥用它将导致测试代码的可维护性降低。你可以阅读这篇文档来了解更多相关信息。 (9). 简化 mock 对象的创建 最小化重复的创建代码; 使测试类的代码可读性更高; 使验证错误更易于阅读，因为字段名可用于标识 mock 对象; public class ArticleManagerTest &#123; @Mock private ArticleCalculator calculator; @Mock private ArticleDatabase database; @Mock private UserProvider userProvider; private ArticleManager manager; 注意！下面这句代码需要在运行测试函数之前被调用,一般放到测试类的基类或者 test runner 中: MockitoAnnotations.initMocks(testClass); 关于 mock 注解的更多信息可以阅读MockitoAnnotations 文档。 (10). 为连续的调用做测试打桩 (stub)有时我们需要为同一个函数调用的不同的返回值或异常做测试桩。 when(mock.someMethod(\"some arg\")) .thenThrow(new RuntimeException()) .thenReturn(\"foo\"); // 第一次调用 : 抛出运行时异常 mock.someMethod(\"some arg\"); // 第二次调用 : 输出\"foo\" System.out.println(mock.someMethod(\"some arg\")); // 后续调用 : 也是输出\"foo\" System.out.println(mock.someMethod(\"some arg\")); 另外，连续调用的另一种更简短的版本 : // 第一次调用时返回\"one\",第二次返回\"two\",第三次返回\"three\" when(mock.someMethod(\"some arg\")) .thenReturn(\"one\", \"two\", \"three\"); (11). 为回调做测试桩when(mock.someMethod(anyString())).thenAnswer(new Answer() &#123; Object answer(InvocationOnMock invocation) &#123; Object[] args = invocation.getArguments(); Object mock = invocation.getMock(); return \"called with arguments: \" + args; &#125; &#125;); // 输出 : \"called with arguments: foo\" System.out.println(mock.someMethod(\"foo\")); (12). 监控真实对象你可以为真实对象创建一个监控(spy)对象。当你使用这个 spy 对象时真实的对象也会也调用，除非它的函数被 stub 了。尽量少使用 spy 对象，使用时也需要小心形式，例如 spy 对象可以用来处理遗留代码。 List list = new LinkedList(); List spy = spy(list); // 你可以为某些函数打桩 when(spy.size()).thenReturn(100); // 通过spy对象调用真实对象的函数 spy.add(\"one\"); spy.add(\"two\"); // 输出第一个元素 System.out.println(spy.get(0)); // 因为size()函数被打桩了,因此这里返回的是100 System.out.println(spy.size()); // 交互验证 verify(spy).add(\"one\"); verify(spy).add(\"two\"); Mockito 并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被 stub 的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。因此结论就是: 当你在监控一个真实对象时，你想在 stub 这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。 (13). 重置 mocks 对象聪明的 Mockito 使用者很少会用到这个特性，因为他们知道这是出现糟糕测试单元的信号。通常情况下你不会需要重设你的测试单元，只需要为每一个测试方法重新创建一个测试单元就可以了。如果你真的想通过 reset()方法满足某些需求的话，请考虑实现简单，小而且专注于测试方法而不是冗长，精确的测试。首先可能出现的代码异味就是测试方法中间那的 reset()方法。这可能意味着你已经过度测试了。添加 reset() 方法的唯一原因就是让它能与容器注入的测试单元协作。 List mock = mock(List.class); when(mock.size()).thenReturn(10); mock.add(1); reset(mock); //at this point the mock forgot any interactions &amp; stubbing (14). 更多的注解 @Captor: 创建 ArgumentCaptor。 @Spy: 可以代替 spy(Object)。 @InjectMocks: 如果此注解声明的变量需要用到 mock 对象，mockito 会自动注入 mock 或 spy 成员。 //可以这样写 @Spy BeerDrinker drinker = new BeerDrinker(); //也可以这样写，mockito会自动实例化drinker. @Spy BeerDrinker drinker; //会自动实例化LocalPub @InjectMocks LocalPub pub; (15). BDD 风格的验证(Since 1.10.0)开启 Behavior Driven Development(BDD，即行为驱动开发)风格的验证可以通过 BBD 的关键词 then 开始验证。 given(dog.bark()).willReturn(2); // when ... then(person).should(times(2)).ride(bike); 以上就是 Mockito 的主要使用方式，关于更详细的介绍可参考Mockito 官方文档和Mockito 中文文档。 4. Spring Test目前几乎大多数 Java web 项目都是有基于 Spring 来开发的。通过 Spring 进行 bean 管理后，仅仅通过 JUnit 来做测试会有各种麻烦，比如：Spring 容器初始化问题、使用硬编码方式手工获取 Bean、不方便对数据操作的正确性做检查等。这时我们就可以通过 Spring 全家桶中的另一位成员spring-test来帮助我们在 Spring 工程中做单元测试了。以下通过简单的示例来演示其使用。 (1). 加入依赖包通过 Maven 加入 JUnit、spring-test 的 Jar 包(最好其他 Spring 包版本一致)。 &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>xxxx&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> (2). 创建测试类@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(\"/application-context-test.xml\") public class UserDaoTest &#123; /** 自动注入baseDao,默认按名称. */ @Resource private IBaseDao baseDao; @Test @Transactional @Rollback public void insert() &#123; String sql = \"INSERT INTO t_user(c_name, c_password) values(?, ?)\"; Object[] objs = new Object[]&#123;\"zhangsan\", \"123456\"&#125;; baseDao.insert(sql , objs); String sql2 = \"SELECT * FROM t_user WHERE c_name = ? and c_password = ?\"; List&lt;Map&lt;String,Object>> list = baseDao.queryForList(sql1, objs); assertTrue(list.size() > 0); System.out.println(list); &#125; &#125; 使用 Spring Test 可以使用@Autowired 自动注入相关的 bean 信息，而不需要自己手动通过 getBean 去获取相应的 bean 信息。 使用 Spring Test 测试，可以@Transaction 注解，表示该方法使用 spring 的事务，在单元测试中，执行完毕后默认会回滚。 使用@Rollback 注解，标明使用完此方法后事务回滚，可以@Rollback(false)这个注解来使对数据库操作的测试结果不回滚。 (3). 对 Spring MVC 的测试为了测试 web 项目，需要一些 Servlet 相关的模拟对象，比如：MockMVC/MockHttpServletRequest/MockHttpServletResponse/MockHttpSession。使用示例如下： import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.forwardedUrl; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.model; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.mock.web.MockHttpServletRequest; import org.springframework.mock.web.MockHttpSession; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.test.context.web.WebAppConfiguration; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import org.springframework.web.context.WebApplicationContext; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(\"/application-context-test.xml\") @WebAppConfiguration(\"src/main/resources\") // 此注解指定web资源的位置，默认为src/main/webapp public class TestControllerIntegrationTests &#123; private MockMvc mockMvc; // 模拟MVC对象 @Autowired private DemoService demoService;// 在测试用例注入spring的bean @Autowired WebApplicationContext wac; // 注入WebApplicationContext @Autowired MockHttpSession session; // 注入模拟的http session @Autowired MockHttpServletRequest request; // 模拟request @Before // 测试开始前的初始化工作 public void setup() &#123; this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(); //2 &#125; @Test public void testNormalController() throws Exception&#123; String exp_str = demoService.saySomething(); // expect str mockMvc.perform(get(\"/normal\")) // 模拟GET /normal .andExpect(status().isOk())// 预期返回状态为200 .andExpect(view().name(\"page\"))// 预期view的名称 .andExpect(forwardedUrl(\"/WEB-INF/classes/views/page.jsp\"))// 预期页面转向的真正路径 .andExpect(model().attribute(\"msg\", exp_str));// 预期model里的值 &#125; @Test public void testRestController() throws Exception&#123; mockMvc.perform(get(\"/testRest\")) // HTTP GET 方法 .andExpect(status().isOk()) .andExpect(content().contentType(\"text/plain;charset=UTF-8\"))//14 .andExpect(content().string(demoService.saySomething()));//15 &#125; &#125; 注:demoService 及相关方法的调用，也可以通过 Mockito 工具 Mock 出来，更符合单元测试对单元性的要求，否则这些测试又额外附带了一定集成测试的性质了。 4. spring-boot-starter-test(1). 简单介绍现在越来越多的应用都采用 SpringBoot 的方式来构建，在 SpringBoot 应用中单元测试变得更加容易了，只需要加入 spring-boot-starter-test 的 Starter 即可，其中默认导入了 Spring Boot 测试模块以及 JUnit，AssertJ，Hamcrest 和其他一些有用的库。 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> spring-boot-starter-test 的 Starter (Scope 为 test)，包括了以下提供的类库： JUnit：单元测试 Java 应用程序的事实标准。 Spring Test和 Spring Boot Test：Spring Boot 应用程序的实用程序和集成测试支持。 AssertJ：流畅的断言库。 Hamcrest：匹配器对象库。 Mockito：Java Mock 框架。 JSONassert：JSON 的断言库。 JsonPath：JSON 的 XPath。 我们通常在编写测试时发现这些通用库都是比较有用的。如果这些库还不适合您的需求，您还可以添加您自己的附加测试依赖库。Spring Boot 提供了一个@SpringBootTest 注释，当您需要 Spring Boot 功能时，它可以用作标准 spring-test@ContextConfiguration 注释的替代方法。注解的工作原理是通过 SpringApplication 创建用于测试的 ApplicationContext。除了@SpringBootTest 之外，还提供了许多其他注释来测试应用程序的更具体的切片。提示：不要忘记在测试中添加@RunWith(SpringRunner.class)，否则注释将被忽略。 (2). 一个简单示例@RunWith(SpringRunner.class) @SpringBootTest public class UserServiceTest &#123; @Value(\"$&#123;msg&#125;\") private String msg; @Autowired private UserService userService; @Test public void getUser() &#123; User user = userService.selectByKey(20180302325L); Assert.assertThat(user.getName(), is(\"Blinkfox\")); System.out.println(\"获取的配置信息为:\" + msg); &#125; &#125; 上面就是最简单的单元测试写法，测试类上只需要@RunWith(SpringRunner.class)和@SpringBootTest 两个注解即可测试任何类和方法。 (3). web 模块的单元测试要测试 Spring MVC 控制器是否按预期工作，请使用@WebMvcTest 注释。@WebMvcTest 自动配置 Spring MVC 基础结构，并将扫描的 bean 限制为@Controller，@ControllerAdvice，@JsonComponent，Converter，GenericConverter，Filter，WebMvcConfigurer 和 HandlerMethodArgumentResolver。 使用此注释时，不会扫描常规的@Componentbean。您还可以使用@AutoConfigureMockMvc 对其进行注释，从而在非@WebMvcTest（如@SpringBootTest）中自动配置 MockMvc。 以下示例使用 MockMvc： @RunWith(SpringRunner.class) @WebMvcTest(UserVehicleController.class) public class MyControllerTests &#123; @Autowired private MockMvc mvc; @MockBean private UserVehicleService userVehicleService; @Test public void testExample() throws Exception &#123; given(this.userVehicleService.getVehicleDetails(\"sboot\")) .willReturn(new VehicleDetails(\"Honda\", \"Civic\")); this.mvc.perform(get(\"/sboot/vehicle\").accept(MediaType.TEXT_PLAIN)) .andExpect(status().isOk()).andExpect(content().string(\"Honda Civic\")); &#125; &#125; SpringBoot 对各种单元测试的场景支持的比较全，更多的示例可直接在Spiring Boot Test 官方指南中去查看，这里就不再一一列举了。 5. JaCoCo在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到 80％或 90％。目前 Java 常用覆盖率工具clover、Jacoco和Cobertura等。关于这些代码覆盖率工具的对比可参看这里。这里我们就选取 Jacoco 来作为代码覆盖率工具来做介绍。Jacoco 是一个开源的覆盖率工具。Jacoco 可以嵌入到 Ant 、Maven 中，并提供了 Eclipse、IDEA 插件,也可以使用 Java Agent 技术监控 Java 程序。很多第三方的工具提供了对 Jacoco 的集成，如 sonar、Jenkins。Jacoco 与 Maven 的集成很简单，只需要在 plugins 中添加如下插件即可。 &lt;plugin> &lt;groupId>org.jacoco&lt;/groupId> &lt;artifactId>jacoco-maven-plugin&lt;/artifactId> &lt;version>0.7.7.201606060606&lt;/version> &lt;configuration> &lt;destFile>target/coverage-reports/jacoco-unit.exec&lt;/destFile> &lt;dataFile>target/coverage-reports/jacoco-unit.exec&lt;/dataFile> &lt;/configuration> &lt;executions> &lt;execution> &lt;id>jacoco-initialize&lt;/id> &lt;goals> &lt;goal>prepare-agent&lt;/goal> &lt;/goals> &lt;/execution> &lt;execution> &lt;id>jacoco-site&lt;/id> &lt;phase>package&lt;/phase> &lt;goals> &lt;goal>report&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;/plugin> 做单元测试时，测试覆盖率是不是越高代表代码质量越好呢？Martin Fowler（重构那本书的作者）曾经写过一篇博客来讨论这个问题，他指出：把测试覆盖作为质量目标没有任何意义，而我们应该把它作为一种发现未被测试覆盖的代码的手段。所以，代码覆盖率统计是用来发现没有被测试覆盖的代码；代码覆盖率统计不能完全用来衡量代码质量。 参考资料 单元测试大揭密 JUnit 教程 JUnit5 用户指南中文版 Mockito 中文文档 单元测试准则","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.sbwit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.sbwit.com/tags/SpringBoot/"},{"name":"单元测试","slug":"单元测试","permalink":"https://www.sbwit.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"DEMO","slug":"yuque/DEMO","date":"2017-12-13T15:40:07.000Z","updated":"2021-04-23T11:22:20.646Z","comments":true,"path":"2017/12/13/yuque/DEMO/","link":"","permalink":"https://www.sbwit.com/2017/12/13/yuque/DEMO/","excerpt":"","text":"name: Blog CI/CD on: [push, repository_dispatch] jobs: blog-cicd: name: Hexo blog build &amp; deploy runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: - name: Checkout codes uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache node modules uses: actions/cache@v1 with: path: ~/.npm key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; - name: Install dependencies run: | npm install hexo-cli -g npm install yuque-hexo -g npm install yuque-hexo sync - name: Generate files run: hexo generate - name: Deploy blog evn: Github_Pages: github.com/sbwit/sbwit.github.io Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125; run: | git clone \"https://$&#123;Github_Pages&#125;\" deploy_git mv ./deploy_git/.git ./public/ cd ./public git config user.name \"sbwit\" git config user.email \"17740857130@qq.com\" git add . git commit -m \"GitHub Actions Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')\" git push --force --quiet \"https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;\" master:master # -*- coding: utf8 -*- import requests def main_handler(event, context): r = requests.post(\"https://api.github.com/repos/sbwit/sbwit.hexo/dispatches\", json = &#123;\"event_type\": \"start\"&#125;, headers = &#123;\"User-Agent\":'curl/7.52.1', 'Content-Type': 'application/json', 'Accept': 'application/vnd.github.everest-preview+json', 'Authorization': 'token GITHUB_TOKEN(自己的)'&#125;) if r.status_code == 204: return \"This's OK!\" else: return r.status_code 官方的配置 # workflow name name: CI Hexo # master branch on push, auto run on: push: branches: - master jobs: Deploy-Pages: name: Deploy Hexo Public To Pages runs-on: ubuntu-latest steps: # check it to your workflow can access it # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # from: https://github.com/actions/setup-node - name: Setup Node.js 10.x uses: actions/setup-node@master with: node-version: \"12.14\" - name: Setup Git Infomation run: | git config --global user.name 'sbwit' git config --global user.email '17740857130@163.com' - name: Get Latest Commit Message run: | git log --pretty=format:\"%s from Github Actions at `date +\"%Y-%m-%d %H:%M:%S\"`\" --date=short -n 1 > commit-message.log - name: Setup Hexo Dependencies run: | npm install hexo-cli -g npm install - name: Generate public files run: | hexo clean hexo generate - name: Deploy To Github Pages env: Github_Pages: github.com/sbwit/sbwit.github.io Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125; run: | git clone https://$&#123;Github_Pages&#125; .github_pages cd .github_pages git checkout master cd ../ mv .github_pages/.git/ ./public/ cd ./public/ git add . git commit -F ../commit-message.log git push --force --quiet \"https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;\" master:master","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.sbwit.com/categories/Hexo/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.sbwit.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.sbwit.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://www.sbwit.com/tags/Github/"}]}],"categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.sbwit.com/categories/SpringBoot/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.sbwit.com/categories/Hexo/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.sbwit.com/tags/SpringBoot/"},{"name":"单元测试","slug":"单元测试","permalink":"https://www.sbwit.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.sbwit.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.sbwit.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://www.sbwit.com/tags/Github/"}]}